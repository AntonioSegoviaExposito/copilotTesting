/**
 * VCF Manager - Contact Manager Module
 * 
 * PURPOSE: Core contact management and UI rendering system
 * DEPENDENCIES: VCFParser, PhoneUtils, Config
 * USED BY: app.js (creates global instance), MergeTool, AutoMerger
 * 
 * This module handles:
 * - Loading and storing contact data
 * - Contact filtering and sorting
 * - Contact selection state management
 * - UI rendering (contact grid, FAB, stats)
 * - Bulk operations (delete, export)
 * 
 * STATE MANAGEMENT:
 * - contacts: Array of all contacts
 * - selected: Set of selected contact IDs (fast lookup)
 * - selectOrder: Array of IDs in selection order (for numbering)
 * - filterStr: Current filter string (lowercase for case-insensitive)
 * - sortAZ: Boolean flag for alphabetical sort
 * 
 * AI MAINTENANCE NOTES:
 * - Selection uses both Set (fast lookup) and Array (ordering) for efficiency
 * - Filter is applied before sorting for better UX
 * - UI updates are batched in render() to minimize reflows
 * - FAB (Floating Action Button) changes based on selection count
 * - To add new display field, update _createCard() method
 */

import Config from '../config.js';
import PhoneUtils from '../utils/phone.js';
import Toast from '../utils/toast.js';
import VCFParser from './vcf-parser.js';
import { escapeHtml, isValidHexColor } from '../utils/html.js';

/**
 * @typedef {Object} Contact
 * @property {string} _id - Unique identifier (generated by VCFParser)
 * @property {string} fn - Full name (required)
 * @property {string[]} tels - Phone numbers (normalized)
 * @property {string[]} emails - Email addresses
 * @property {string} org - Organization name
 * @property {string} [title] - Job title (optional)
 * @property {string} [adr] - Address (optional)
 * @property {string} [note] - Notes (optional)
 * @property {string} [url] - Website URL (optional)
 * @property {string} [bday] - Birthday in YYYY-MM-DD format (optional)
 * @property {string} [photo] - Photo URI or data URI (optional, v4.0)
 * @property {string} [gender] - Gender (optional, v4.0)
 * @property {string} [kind] - Entity type (optional, v4.0, defaults to "individual")
 * @property {string} [anniversary] - Anniversary date (optional, v4.0)
 * @property {string} [lang] - Preferred language (optional, v4.0)
 * @property {string[]} [impp] - Instant messaging addresses (optional, v4.0)
 * @property {string} [geo] - Geographic position (optional, v4.0)
 * @property {string} [tz] - Time zone (optional, v4.0)
 * @property {string} [nickname] - Nickname (optional)
 * @property {string} [categories] - Categories (optional)
 * @property {string} [role] - Role (optional)
 */

/**
 * Contact Manager Class
 * Manages contact list, selection, filtering, sorting, and UI rendering
 */
class ContactManager {
    /**
     * Initialize ContactManager with empty state
     * 
     * INITIAL STATE:
     * - Empty contact list
     * - No selections
     * - No active filter
     * - Sort by creation order (not alphabetical)
     * - Show all contacts (not filtering by phone presence)
     */
    constructor() {
        /** @type {Contact[]} Array of all contacts */
        this.contacts = [];
        
        /** @type {Set<string>} Set of selected contact IDs (for fast lookup) */
        this.selected = new Set();
        
        /** @type {string[]} Array of selected IDs in selection order (for badge numbering) */
        this.selectOrder = [];
        
        /** @type {string} Current filter string (lowercase for case-insensitive search) */
        this.filterStr = '';
        
        /** @type {boolean} Sort alphabetically (true) or by creation order (false) */
        this.sortAZ = false;
        
        /** @type {boolean} Show only contacts without phone numbers (false = show all) */
        this.showOnlyWithoutPhones = false;
        
        /** @type {number} Counter for import groups to assign unique colors */
        this.importGroupCounter = 0;
        
        /** @type {string[]} Array of colors for import groups */
        this.importGroupColors = [
            '#2563eb', // blue
            '#16a34a', // green
            '#f59e0b', // orange
            '#ef4444', // red
            '#8b5cf6', // purple
            '#ec4899', // pink
            '#06b6d4', // cyan
            '#84cc16'  // lime
        ];
    }

    /**
     * Initialize DOM event listeners
     * 
     * SETUP:
     * - Binds file input change event to loadFile()
     * - Sets up drag and drop handlers for file import
     * 
     * CALLED BY: initApp() in app.js after instance creation
     * 
     * @returns {void}
     */
    init() {
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            // Bind file selection to loadFiles method (supports multiple files)
            fileInput.addEventListener('change', (e) => this.loadFiles(e.target.files));
        }
        
        // Set up drag and drop for file import
        this._setupDragAndDrop();
    }

    /**
     * Set up drag and drop event handlers for file import
     * 
     * LOGIC:
     * 1. Create drop zone overlay (hidden by default)
     * 2. Attach drag event listeners to document
     * 3. Show overlay when files are dragged over page
     * 4. Process dropped files with same loadFiles() method
     * 5. Hide overlay when drag ends
     * 
     * SECURITY:
     * - Only accepts .vcf files
     * - Validates file types before processing
     * - Prevents default browser behavior for security
     * 
     * @private
     * @returns {void}
     */
    _setupDragAndDrop() {
        // Create drop zone overlay
        const dropZone = document.createElement('div');
        dropZone.id = 'dropZone';
        dropZone.className = 'drop-zone';
        dropZone.innerHTML = `
            <div class="drop-zone-content">
                <div class="drop-zone-icon">üìÇ</div>
                <div class="drop-zone-text">Drop VCF files here</div>
                <div class="drop-zone-hint">.vcf files supported</div>
            </div>
        `;
        document.body.appendChild(dropZone);
        
        let dragCounter = 0; // Track nested drag enter/leave events
        
        // Prevent default drag behaviors on document
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
        
        document.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Check if dragging files (not text or other elements)
            if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                dragCounter++;
                if (dragCounter === 1) {
                    dropZone.classList.add('drop-zone-active');
                }
            }
        });
        
        document.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Only decrement if we had previously incremented
            if (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')) {
                dragCounter--;
                if (dragCounter === 0) {
                    dropZone.classList.remove('drop-zone-active');
                }
            }
        });
        
        document.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            dragCounter = 0;
            dropZone.classList.remove('drop-zone-active');
            
            // Get dropped files
            const files = e.dataTransfer.files;
            
            if (files && files.length > 0) {
                // Filter for .vcf files only
                const vcfFiles = Array.from(files).filter(file => 
                    file.name.toLowerCase().endsWith('.vcf')
                );
                
                if (vcfFiles.length > 0) {
                    // Convert array to FileList-like object
                    const fileList = this._createFileList(vcfFiles);
                    this.loadFiles(fileList);
                } else {
                    Toast.warning('Please drop VCF (.vcf) files');
                }
            }
        });
    }

    /**
     * Create a FileList-like object from an array of files
     * 
     * FileList is read-only, so we create a compatible object
     * 
     * @private
     * @param {File[]} files - Array of File objects
     * @returns {Object} FileList-like object
     */
    _createFileList(files) {
        const fileList = {};
        files.forEach((file, index) => {
            fileList[index] = file;
        });
        fileList.length = files.length;
        return fileList;
    }

    /**
     * Load contacts from multiple VCF files
     * 
     * LOADING PROCESS:
     * 1. Process each file sequentially
     * 2. Assign unique import group to each file
     * 3. Parse contacts and add import group metadata
     * 4. Append to existing contacts (doesn't replace)
     * 5. Re-render UI to display all contacts
     * 
     * Each import group gets a unique color for visual identification.
     * 
     * @param {FileList} files - FileList object from file input
     * @returns {void}
     * 
     * @example
     * // Called from file input event listener
     * fileInput.addEventListener('change', (e) => this.loadFiles(e.target.files));
     */
    loadFiles(files) {
        if (!files || files.length === 0) return;

        // Convert FileList to Array for easier processing
        const fileArray = Array.from(files);
        
        // Process files sequentially
        this._processFilesSequentially(fileArray, 0);
    }

    /**
     * Process files sequentially to maintain import group order
     * @private
     */
    _processFilesSequentially(fileArray, index) {
        if (index >= fileArray.length) {
            // All files processed, render UI
            this.render();
            
            // Show success toast
            const fileCount = fileArray.length;
            Toast.success(`${fileCount} ${fileCount === 1 ? 'file imported' : 'files imported'} successfully`);
            return;
        }

        const file = fileArray[index];
        const importGroupId = this.importGroupCounter++;
        const importColor = this.importGroupColors[importGroupId % this.importGroupColors.length];

        // Use FileReader API to read file as text
        const reader = new FileReader();
        reader.onload = (e) => {
            // Parse VCF content
            const newContacts = VCFParser.parse(e.target.result);
            
            // Add import group metadata to each contact
            newContacts.forEach(contact => {
                contact._importGroup = importGroupId;
                contact._importColor = importColor;
                contact._importFileName = file.name;
            });
            
            // Append to existing contacts
            this.contacts = this.contacts.concat(newContacts);
            
            // Process next file
            this._processFilesSequentially(fileArray, index + 1);
        };
        
        reader.onerror = () => {
            Toast.error(`Error reading file: ${file.name}`);
            // Continue with next file even if this one fails
            this._processFilesSequentially(fileArray, index + 1);
        };
        
        reader.readAsText(file);
    }

    /**
     * Load contacts from a single VCF file (legacy method)
     * 
     * LOADING PROCESS:
     * 1. Validate file is provided
     * 2. Create FileReader to read file content
     * 3. Parse VCF content into contact objects
     * 4. Replace current contacts with parsed contacts
     * 5. Re-render UI to display new contacts
     * 
     * NOTE: This replaces all existing contacts. To add contacts,
     * use merge operations instead. For multiple files, use loadFiles().
     * 
     * @param {File} file - VCF file object from file input
     * @returns {void}
     * 
     * @example
     * // Called from file input event listener (single file mode)
     * fileInput.addEventListener('change', (e) => this.loadFile(e.target.files[0]));
     */
    loadFile(file) {
        if (!file) return;

        // Use FileReader API to read file as text
        const reader = new FileReader();
        reader.onload = (e) => {
            // Parse VCF content and replace current contacts
            this.contacts = VCFParser.parse(e.target.result);
            
            // Render UI with new contacts
            this.render();
        };
        reader.readAsText(file);
    }

    /**
     * Export all contacts to VCF file
     * 
     * Triggers browser download of all contacts in VCF format.
     * File name format: contacts_[timestamp].vcf
     * 
     * DELEGATES TO: VCFParser.download() which handles:
     * - Converting contacts to VCF format
     * - Creating download blob
     * - Triggering browser download
     * - Showing alert if list is empty
     * 
     * @returns {void}
     * 
     * @example
     * // Called from Export button
     * <button onclick="core.exportVCF()">Export</button>
     */
    exportVCF() {
        VCFParser.download(this.contacts);
    }

    /**
     * Set filter string and re-render
     * 
     * FILTER LOGIC:
     * - Converts to lowercase for case-insensitive search
     * - Filters applied in render() method
     * - Searches in contact name (fn) and phone numbers (tels)
     * 
     * @param {string} value - Filter string (user input from search box)
     * @returns {void}
     * 
     * @example
     * // Called from search input
     * <input oninput="core.setFilter(this.value)">
     */
    setFilter(value) {
        // Store as lowercase for case-insensitive filtering
        this.filterStr = value.toLowerCase();
        
        // Re-render to apply filter
        this.render();
    }

    /**
     * Toggle sort order between alphabetical and creation order
     * 
     * SORT MODES:
     * - sortAZ = false: Creation order (order contacts were added/parsed)
     * - sortAZ = true: Alphabetical by full name (localeCompare)
     * 
     * Shows user-friendly alert message to confirm sort change.
     * 
     * @returns {void}
     * 
     * @example
     * // Called from sort button
     * <button onclick="core.toggleSort()">Ordenar A-Z</button>
     */
    toggleSort() {
        // Toggle sort flag
        this.sortAZ = !this.sortAZ;
        
        // Re-render with new sort order
        this.render();
        
        // Show confirmation message
        Toast.info(this.sortAZ ? Config.messages.sortAlpha : Config.messages.sortCreation);
    }

    /**
     * Toggle filter to show only contacts without phone numbers
     * 
     * FILTER MODES:
     * - showOnlyWithoutPhones = false: Show all contacts (default)
     * - showOnlyWithoutPhones = true: Show only contacts with no phone numbers
     * 
     * This is a display-only filter that doesn't modify contact data.
     * Useful for finding contacts that need phone numbers added.
     * 
     * @returns {void}
     * 
     * @example
     * // Called from toggle button
     * <button onclick="core.togglePhoneFilter()">Show Only Without Phones</button>
     */
    togglePhoneFilter() {
        // Toggle phone filter flag
        this.showOnlyWithoutPhones = !this.showOnlyWithoutPhones;
        
        // Re-render to apply filter
        this.render();
        
        // Update toggle button text and visual state to reflect current filter
        const toggleBtn = document.getElementById('btnTogglePhones');
        if (toggleBtn) {
            if (this.showOnlyWithoutPhones) {
                toggleBtn.innerText = 'üìµ Show All';
                toggleBtn.classList.add('btn-pulse-red');
            } else {
                toggleBtn.innerText = 'üìµ No Phone';
                toggleBtn.classList.remove('btn-pulse-red');
            }
        }
    }

    /**
     * Render the contact grid
     * 
     * RENDERING PIPELINE:
     * 1. Clear existing grid content
     * 2. Update stats display (total count)
     * 3. Filter contacts by search term
     * 4. Sort contacts if alphabetical mode enabled
     * 5. Show empty state or create contact cards
     * 6. Update FAB (Floating Action Button) state
     * 
     * FILTER LOGIC:
     * - Case-insensitive search in full name (fn)
     * - Case-insensitive search in all phone numbers (tels)
     * - Contact matches if ANY field contains filter string
     * 
     * SORT LOGIC:
     * - If sortAZ = true: Sort alphabetically by full name
     * - If sortAZ = false: Keep creation/load order
     * 
     * PERFORMANCE NOTES:
     * - Batches all DOM updates in single render pass
     * - Uses innerHTML for stats (fast for simple text)
     * - Uses createElement + appendChild for cards (safer for dynamic content)
     * 
     * @returns {void}
     * 
     * @example
     * // Called after state changes
     * this.contacts = newContacts;
     * this.render(); // Update UI
     */
    render() {
        const grid = document.getElementById('grid');
        if (!grid) return;

        // Clear existing content
        grid.innerHTML = '';

        // === UPDATE STATS ===
        const statDisplay = document.getElementById('statDisplay');
        const btnExport = document.getElementById('btnExport');
        
        if (statDisplay) statDisplay.innerText = `${this.contacts.length} contacts`;
        if (btnExport) btnExport.innerText = `Export (${this.contacts.length})`;

        // === FILTER CONTACTS ===
        // Filter by name or phone numbers (case-insensitive)
        let visible = this.contacts.filter(c =>
            c.fn.toLowerCase().includes(this.filterStr) ||
            c.tels.some(t => t.includes(this.filterStr))
        );

        // Apply phone filter if enabled (show only contacts without phones)
        if (this.showOnlyWithoutPhones) {
            visible = visible.filter(c => c.tels.length === 0);
        }

        // === SORT CONTACTS ===
        // Apply alphabetical sort if enabled
        if (this.sortAZ) {
            visible.sort((a, b) => a.fn.localeCompare(b.fn));
        }

        // === SHOW EMPTY STATE ===
        if (visible.length === 0) {
            const hasContacts = this.contacts.length > 0;
            const isFiltering = this.filterStr.length > 0;
            if (hasContacts || isFiltering) {
                // Filtered but no matches
                grid.innerHTML = `<div class="empty-state">
                    <div class="empty-state-icon">üîç</div>
                    <div class="empty-state-text">No contacts match your search</div>
                    <div class="empty-state-hint">Try a different search term</div>
                </div>`;
            } else {
                // No contacts at all
                grid.innerHTML = `<div class="empty-state">
                    <div class="empty-state-icon">üìá</div>
                    <div class="empty-state-text">${Config.messages.noData}</div>
                    <div class="empty-state-hint">Import a VCF file or add a contact to get started</div>
                    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">üìÇ Import VCF</button>
                </div>`;
            }
            this._updateFAB();
            return;
        }

        // === RENDER CONTACT CARDS ===
        visible.forEach(contact => {
            const card = this._createCard(contact);
            grid.appendChild(card);
        });

        // === UPDATE FAB ===
        // Show/hide and update floating action button
        this._updateFAB();
    }

    /**
     * Create a contact card element
     * 
     * CARD STRUCTURE:
     * - Badge: Selection number (1, 2, 3...)
     * - Name: Full name (bold, larger font)
     * - Organization: Company/org name (smaller, gray)
     * - Phone numbers: Up to maxTelsDisplay (3) shown with icons
     * - "More" indicator: Shows if more than maxTelsDisplay phones
     * 
     * SELECTION STATE:
     * - Selected cards have 'selected' class (background highlight)
     * - Badge shows selection order number (1-indexed)
     * - Card click or Enter/Space key toggles selection
     * 
     * ACCESSIBILITY:
     * - Cards have tabindex="0", role="button", aria-label, aria-pressed
     * - Enter and Space keys toggle selection (same as click)
     * 
     * PHONE NUMBER DISPLAY:
     * - Shows up to Config.ui.maxTelsDisplay (3) phone numbers
     * - Formats each with PhoneUtils.format() for display
     * - Shows "+N mas" if more phones exist
     * 
     * @private
     * @param {Contact} contact - Contact object to render
     * @returns {HTMLElement} DOM element (div.card) ready to append
     * 
     * @example
     * const card = this._createCard(contact);
     * grid.appendChild(card);
     */
    _createCard(contact) {
        // Check if this contact is selected
        const isSelected = this.selected.has(contact._id);
        
        // Get selection order (for badge number display)
        const selectionIndex = this.selectOrder.indexOf(contact._id);

        // Create card container
        const card = document.createElement('div');
        card.className = `card ${isSelected ? 'selected' : ''}`;
        card.setAttribute('tabindex', '0');
        card.setAttribute('role', 'button');
        card.setAttribute('aria-label', `${contact.fn}${isSelected ? ', selected' : ''}`);
        card.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
        
        // Add import group indicator if present (with validation)
        if (contact._importColor && isValidHexColor(contact._importColor)) {
            card.style.borderLeft = `4px solid ${contact._importColor}`;
            card.setAttribute('data-import-group', contact._importGroup);
            if (contact._importFileName) {
                card.setAttribute('title', `Imported from: ${escapeHtml(contact._importFileName)}`);
            }
        }
        
        // Bind click and keyboard to toggle selection
        card.onclick = () => this.toggleSelect(contact._id);
        card.onkeydown = (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                this.toggleSelect(contact._id);
            }
        };

        // Format phone numbers for display
        // Show up to maxTelsDisplay phones with formatting
        const telsHtml = contact.tels
            .slice(0, Config.ui.maxTelsDisplay)
            .map(t => `<span>üìû ${escapeHtml(PhoneUtils.format(t))}</span>`)
            .join('');

        // Show "more" indicator if additional phones exist
        const moreTels = contact.tels.length > Config.ui.maxTelsDisplay
            ? `<small style="color:var(--text-light)">+${contact.tels.length - Config.ui.maxTelsDisplay} more</small>`
            : '';

        // Build card HTML
        // Badge shows selection number (1-indexed) when selected
        // Photo thumbnail and nickname shown when available (v4.0)
        const photoHtml = contact.photo
            ? `<img src="${escapeHtml(contact.photo)}" alt="" class="card-photo" onerror="this.style.display='none'">`
            : '';
        
        const nicknameHtml = contact.nickname
            ? `<div class="card-nickname">${escapeHtml(contact.nickname)}</div>`
            : '';

        card.innerHTML = `
            <div class="badge">${selectionIndex + 1}</div>
            <div class="card-header">
                ${photoHtml}
                <div class="card-header-info">
                    <div style="font-weight:bold; font-size:1.05rem;">${escapeHtml(contact.fn)}</div>
                    ${nicknameHtml}
                </div>
            </div>
            <div style="font-size:0.8rem; color:var(--text-muted); margin-bottom:8px;">${escapeHtml(contact.org || '')}</div>
            <div style="display:flex; flex-direction:column; gap:4px; font-size:0.85rem; color:var(--text);">
                ${telsHtml}
                ${moreTels}
            </div>
        `;

        return card;
    }

    /**
     * Update the floating action button state
     * 
     * FAB BEHAVIOR:
     * - Hidden when no contacts selected
     * - Visible when 1+ contacts selected
     * - Shows selection count
     * - Button text changes based on selection:
     *   - 1 selected: "‚úèÔ∏è EDIT" (edit single contact)
     *   - 2+ selected: "‚ö° MERGE" (merge multiple contacts)
     * 
     * DOM ELEMENTS UPDATED:
     * - #fab: Main button (add/remove 'visible' class)
     * - #selCount: Selection count text
     * - #fabActionText: Action label (EDIT vs MERGE)
     * 
     * @private
     * @returns {void}
     */
    _updateFAB() {
        const fab = document.getElementById('fab');
        const selCount = document.getElementById('selCount');
        const fabActionText = document.getElementById('fabActionText');
        const fabCloneBtn = document.getElementById('fabCloneBtn');

        if (!fab) return;

        if (this.selected.size > 0) {
            // Show FAB when contacts selected
            fab.classList.add('visible');
            
            // Update selection count
            if (selCount) selCount.innerText = this.selected.size;
            
            // Update action text based on selection count
            if (fabActionText) {
                fabActionText.innerText = this.selected.size === 1 ? "‚úèÔ∏è EDIT" : "‚ö° MERGE";
            }
            
            // Show clone button only when exactly 1 contact selected
            if (fabCloneBtn) {
                fabCloneBtn.style.display = this.selected.size === 1 ? 'block' : 'none';
            }
        } else {
            // Hide FAB when no selection
            fab.classList.remove('visible');
        }
    }

    /**
     * Toggle contact selection
     * 
     * SELECTION LOGIC:
     * - If already selected: Remove from both Set and order Array
     * - If not selected: Add to both Set and order Array
     * 
     * DUAL DATA STRUCTURE:
     * - selected (Set): Fast O(1) lookup for "is selected?" checks
     * - selectOrder (Array): Maintains selection order for badge numbering
     * 
     * After toggling, triggers re-render to update:
     * - Card visual state (selected class)
     * - Badge numbers (based on order)
     * - FAB visibility and text
     * 
     * @param {string} id - Contact ID (_id property)
     * @returns {void}
     * 
     * @example
     * // Called from card click handler
     * card.onclick = () => this.toggleSelect(contact._id);
     */
    toggleSelect(id) {
        if (this.selected.has(id)) {
            // Deselect: Remove from both structures
            this.selected.delete(id);
            this.selectOrder = this.selectOrder.filter(x => x !== id);
        } else {
            // Select: Add to both structures
            this.selected.add(id);
            this.selectOrder.push(id);
        }
        
        // Re-render to update UI
        this.render();
    }

    /**
     * Select all contacts
     * 
     * Adds all contacts to selection (both Set and order Array).
     * Only adds contacts that aren't already selected to preserve order.
     * 
     * USE CASE: Bulk operations (merge all, delete all)
     * 
     * @returns {void}
     * 
     * @example
     * // Called from "Select All" button
     * <button onclick="core.selectAll()">Seleccionar Todo</button>
     */
    selectAll() {
        this.contacts.forEach(c => {
            // Only add if not already selected (preserves order)
            if (!this.selected.has(c._id)) {
                this.selected.add(c._id);
                this.selectOrder.push(c._id);
            }
        });
        
        // Re-render to update UI
        this.render();
    }

    /**
     * Deselect all contacts
     * 
     * Clears both selection Set and order Array.
     * Also hides FAB (Floating Action Button) via re-render.
     * 
     * @returns {void}
     * 
     * @example
     * // Called from "Deselect All" button
     * <button onclick="core.deselectAll()">Deseleccionar</button>
     */
    deselectAll() {
        this.selected.clear();
        this.selectOrder = [];
        
        // Re-render to update UI
        this.render();
    }

    /**
     * Delete selected contacts
     * 
     * DELETION PROCESS:
     * 1. Show confirmation dialog with count
     * 2. If confirmed, filter out selected contacts
     * 3. Clear selection state
     * 4. Re-render UI
     * 
     * SAFETY:
     * - Requires user confirmation before deletion
     * - Cannot be undone (user must re-load VCF file)
     * 
     * @returns {void}
     * 
     * @example
     * // Called from Delete button
     * <button onclick="core.deleteSelected()">Eliminar</button>
     */
    async deleteSelected() {
        // Show confirmation dialog
        const confirmed = await Toast.confirm(Config.messages.confirmDelete(this.selected.size), 'Delete', 'Cancel');
        if (!confirmed) return;
        
        // Filter out selected contacts
        this.contacts = this.contacts.filter(c => !this.selected.has(c._id));
        
        // Clear selection and re-render
        this.deselectAll();
    }

    /**
     * Clear all contacts
     * 
     * CLEAR PROCESS:
     * 1. Show confirmation dialog
     * 2. If confirmed, empty contacts array
     * 3. Clear selection state
     * 4. Re-render UI (shows empty state)
     * 
     * SAFETY:
     * - Requires user confirmation
     * - Cannot be undone (user must re-load VCF file)
     * - Different from deleteSelected (doesn't require selection)
     * 
     * USE CASE: Reset application to start fresh
     * 
     * @returns {void}
     * 
     * @example
     * // Called from Clear All button
     * <button onclick="core.clearAll()">Clear All</button>
     */
    async clearAll() {
        // Show confirmation dialog
        const confirmed = await Toast.confirm(Config.messages.confirmClear, 'Clear All', 'Cancel');
        if (confirmed) {
            // Clear selection first to avoid stale references
            // Note: Using manual clear instead of deselectAll() to avoid triggering
            // render() twice (once here, once after contacts=[] below)
            this.selected.clear();
            this.selectOrder = [];
            
            // Empty the contacts array
            this.contacts = [];
            
            // Re-render to update UI
            this.render();
        }
    }

    /**
     * Find a contact by ID
     * 
     * LOOKUP LOGIC:
     * - Linear search through contacts array
     * - Returns first contact with matching _id
     * - Returns undefined if not found
     * 
     * USED BY: MergeTool, AutoMerger for retrieving contact details
     * 
     * PERFORMANCE NOTE:
     * - O(n) linear search is acceptable for typical contact list sizes
     * - For very large lists, consider maintaining a Map<id, contact>
     * 
     * @param {string} id - Contact ID (_id property)
     * @returns {Contact|undefined} Contact object if found, undefined otherwise
     * 
     * @example
     * const contact = core.findById('k2x9f8h1643723456789');
     * if (contact) {
     *   console.log(contact.fn); // "John Doe"
     * }
     */
    findById(id) {
        return this.contacts.find(c => c._id === id);
    }

    /**
     * Add a new empty contact
     * 
     * Creates a new empty contact with minimal required fields and opens
     * the merge tool in edit mode for the user to fill in the details.
     * 
     * WORKFLOW:
     * 1. Generate unique ID for new contact
     * 2. Create contact with empty/minimal fields
     * 3. Add to beginning of contacts array (most recent)
     * 4. Select the new contact
     * 5. Open merge tool in edit mode
     * 
     * @returns {void}
     * 
     * @example
     * // Called from "Add Contact" button
     * <button onclick="core.addNewContact()">Add Contact</button>
     */
    addNewContact() {
        // Generate unique ID
        const newId = 'new_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
        
        // Create new empty contact (flag for validation on commit/close)
        const newContact = {
            _id: newId,
            fn: '',
            tels: [],
            emails: [],
            org: '',
            _isNewContact: true
        };
        
        // Add to beginning of contacts array
        this.contacts.unshift(newContact);
        
        // Select the new contact and open edit mode
        this.deselectAll();
        this.toggleSelect(newId);
        
        // Open merge tool in edit mode
        mergeTool.init();
        
        // Re-render to update UI
        this.render();
    }

    /**
     * Clone the selected contact
     * 
     * REQUIREMENTS:
     * - Exactly one contact must be selected
     * - Delegates to mergeTool.cloneContact()
     * 
     * @returns {void}
     * 
     * @example
     * <button onclick="core.cloneSelected()">Clone</button>
     */
    cloneSelected() {
        // Guard: Require exactly one contact selected
        if (this.selected.size !== 1) return;
        
        // Delegate to merge tool clone functionality
        mergeTool.cloneContact();
    }
}

// Export for module usage (ESM)
export default ContactManager;
