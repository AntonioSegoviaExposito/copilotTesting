/**
 * VCF Manager - Contact Manager Module
 * 
 * PURPOSE: Core contact management and UI rendering system
 * DEPENDENCIES: VCFParser, PhoneUtils, Config
 * USED BY: app.js (creates global instance), MergeTool, AutoMerger
 * 
 * This module handles:
 * - Loading and storing contact data
 * - Contact filtering and sorting
 * - Contact selection state management
 * - UI rendering (contact grid, FAB, stats)
 * - Bulk operations (delete, export)
 * 
 * STATE MANAGEMENT:
 * - contacts: Array of all contacts
 * - selected: Set of selected contact IDs (fast lookup)
 * - selectOrder: Array of IDs in selection order (for numbering)
 * - filterStr: Current filter string (lowercase for case-insensitive)
 * - sortAZ: Boolean flag for alphabetical sort
 * 
 * AI MAINTENANCE NOTES:
 * - Selection uses both Set (fast lookup) and Array (ordering) for efficiency
 * - Filter is applied before sorting for better UX
 * - UI updates are batched in render() to minimize reflows
 * - FAB (Floating Action Button) changes based on selection count
 * - To add new display field, update _createCard() method
 */

import Config from '../config.js';
import PhoneUtils from '../utils/phone.js';
import Toast from '../utils/toast.js';
import VCFParser from './vcf-parser.js';

/**
 * Validate that a string is a safe hex color
 * @private
 * @param {string} color - Color to validate
 * @returns {boolean} True if valid hex color
 */
function isValidHexColor(color) {
    return /^#[0-9A-Fa-f]{6}$/.test(color);
}

/**
 * Escape HTML for safe attribute insertion
 * @private
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeHtmlAttr(str) {
    return str.replace(/[&<>"']/g, char => {
        const escape = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        return escape[char];
    });
}

/**
 * @typedef {Object} Contact
 * @property {string} _id - Unique identifier (generated by VCFParser)
 * @property {string} fn - Full name (required)
 * @property {string[]} tels - Phone numbers (normalized)
 * @property {string[]} emails - Email addresses
 * @property {string} org - Organization name
 * @property {string} [title] - Job title (optional)
 * @property {string} [adr] - Address (optional)
 * @property {string} [note] - Notes (optional)
 * @property {string} [url] - Website URL (optional)
 * @property {string} [bday] - Birthday in YYYY-MM-DD format (optional)
 */

/**
 * Contact Manager Class
 * Manages contact list, selection, filtering, sorting, and UI rendering
 */
class ContactManager {
    /**
     * Initialize ContactManager with empty state
     * 
     * INITIAL STATE:
     * - Empty contact list
     * - No selections
     * - No active filter
     * - Sort by creation order (not alphabetical)
     * - Show all contacts (not filtering by phone presence)
     */
    constructor() {
        /** @type {Contact[]} Array of all contacts */
        this.contacts = [];
        
        /** @type {Set<string>} Set of selected contact IDs (for fast lookup) */
        this.selected = new Set();
        
        /** @type {string[]} Array of selected IDs in selection order (for badge numbering) */
        this.selectOrder = [];
        
        /** @type {string} Current filter string (lowercase for case-insensitive search) */
        this.filterStr = '';
        
        /** @type {boolean} Sort alphabetically (true) or by creation order (false) */
        this.sortAZ = false;
        
        /** @type {boolean} Show only contacts without phone numbers (false = show all) */
        this.showOnlyWithoutPhones = false;
        
        /** @type {number} Counter for import groups to assign unique colors */
        this.importGroupCounter = 0;
        
        /** @type {string[]} Array of colors for import groups */
        this.importGroupColors = [
            '#2563eb', // blue
            '#16a34a', // green
            '#f59e0b', // orange
            '#ef4444', // red
            '#8b5cf6', // purple
            '#ec4899', // pink
            '#06b6d4', // cyan
            '#84cc16'  // lime
        ];
    }

    /**
     * Initialize DOM event listeners
     * 
     * SETUP:
     * - Binds file input change event to loadFile()
     * 
     * CALLED BY: initApp() in app.js after instance creation
     * 
     * @returns {void}
     */
    init() {
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            // Bind file selection to loadFiles method (supports multiple files)
            fileInput.addEventListener('change', (e) => this.loadFiles(e.target.files));
        }
    }

    /**
     * Load contacts from multiple VCF files
     * 
     * LOADING PROCESS:
     * 1. Process each file sequentially
     * 2. Assign unique import group to each file
     * 3. Parse contacts and add import group metadata
     * 4. Append to existing contacts (doesn't replace)
     * 5. Re-render UI to display all contacts
     * 
     * Each import group gets a unique color for visual identification.
     * 
     * @param {FileList} files - FileList object from file input
     * @returns {void}
     * 
     * @example
     * // Called from file input event listener
     * fileInput.addEventListener('change', (e) => this.loadFiles(e.target.files));
     */
    loadFiles(files) {
        if (!files || files.length === 0) return;

        // Convert FileList to Array for easier processing
        const fileArray = Array.from(files);
        
        // Process files sequentially
        this._processFilesSequentially(fileArray, 0);
    }

    /**
     * Process files sequentially to maintain import group order
     * @private
     */
    _processFilesSequentially(fileArray, index) {
        if (index >= fileArray.length) {
            // All files processed, render UI
            this.render();
            
            // Show success toast
            const fileCount = fileArray.length;
            Toast.success(`${fileCount} ${fileCount === 1 ? 'archivo importado' : 'archivos importados'} correctamente`);
            return;
        }

        const file = fileArray[index];
        const importGroupId = this.importGroupCounter++;
        const importColor = this.importGroupColors[importGroupId % this.importGroupColors.length];

        // Use FileReader API to read file as text
        const reader = new FileReader();
        reader.onload = (e) => {
            // Parse VCF content
            const newContacts = VCFParser.parse(e.target.result);
            
            // Add import group metadata to each contact
            newContacts.forEach(contact => {
                contact._importGroup = importGroupId;
                contact._importColor = importColor;
                contact._importFileName = file.name;
            });
            
            // Append to existing contacts
            this.contacts = this.contacts.concat(newContacts);
            
            // Process next file
            this._processFilesSequentially(fileArray, index + 1);
        };
        
        reader.onerror = () => {
            Toast.error(`Error al leer el archivo: ${file.name}`);
            // Continue with next file even if this one fails
            this._processFilesSequentially(fileArray, index + 1);
        };
        
        reader.readAsText(file);
    }

    /**
     * Load contacts from a single VCF file (legacy method)
     * 
     * LOADING PROCESS:
     * 1. Validate file is provided
     * 2. Create FileReader to read file content
     * 3. Parse VCF content into contact objects
     * 4. Replace current contacts with parsed contacts
     * 5. Re-render UI to display new contacts
     * 
     * NOTE: This replaces all existing contacts. To add contacts,
     * use merge operations instead. For multiple files, use loadFiles().
     * 
     * @param {File} file - VCF file object from file input
     * @returns {void}
     * 
     * @example
     * // Called from file input event listener (single file mode)
     * fileInput.addEventListener('change', (e) => this.loadFile(e.target.files[0]));
     */
    loadFile(file) {
        if (!file) return;

        // Use FileReader API to read file as text
        const reader = new FileReader();
        reader.onload = (e) => {
            // Parse VCF content and replace current contacts
            this.contacts = VCFParser.parse(e.target.result);
            
            // Render UI with new contacts
            this.render();
        };
        reader.readAsText(file);
    }

    /**
     * Export all contacts to VCF file
     * 
     * Triggers browser download of all contacts in VCF format.
     * File name format: contacts_[timestamp].vcf
     * 
     * DELEGATES TO: VCFParser.download() which handles:
     * - Converting contacts to VCF format
     * - Creating download blob
     * - Triggering browser download
     * - Showing alert if list is empty
     * 
     * @returns {void}
     * 
     * @example
     * // Called from Export button
     * <button onclick="core.exportVCF()">Export</button>
     */
    exportVCF() {
        VCFParser.download(this.contacts);
    }

    /**
     * Set filter string and re-render
     * 
     * FILTER LOGIC:
     * - Converts to lowercase for case-insensitive search
     * - Filters applied in render() method
     * - Searches in contact name (fn) and phone numbers (tels)
     * 
     * @param {string} value - Filter string (user input from search box)
     * @returns {void}
     * 
     * @example
     * // Called from search input
     * <input oninput="core.setFilter(this.value)">
     */
    setFilter(value) {
        // Store as lowercase for case-insensitive filtering
        this.filterStr = value.toLowerCase();
        
        // Re-render to apply filter
        this.render();
    }

    /**
     * Toggle sort order between alphabetical and creation order
     * 
     * SORT MODES:
     * - sortAZ = false: Creation order (order contacts were added/parsed)
     * - sortAZ = true: Alphabetical by full name (localeCompare)
     * 
     * Shows user-friendly alert message to confirm sort change.
     * 
     * @returns {void}
     * 
     * @example
     * // Called from sort button
     * <button onclick="core.toggleSort()">Ordenar A-Z</button>
     */
    toggleSort() {
        // Toggle sort flag
        this.sortAZ = !this.sortAZ;
        
        // Re-render with new sort order
        this.render();
        
        // Show confirmation message
        Toast.info(this.sortAZ ? Config.messages.sortAlpha : Config.messages.sortCreation);
    }

    /**
     * Toggle filter to show only contacts without phone numbers
     * 
     * FILTER MODES:
     * - showOnlyWithoutPhones = false: Show all contacts (default)
     * - showOnlyWithoutPhones = true: Show only contacts with no phone numbers
     * 
     * This is a display-only filter that doesn't modify contact data.
     * Useful for finding contacts that need phone numbers added.
     * 
     * @returns {void}
     * 
     * @example
     * // Called from toggle button
     * <button onclick="core.togglePhoneFilter()">Show Only Without Phones</button>
     */
    togglePhoneFilter() {
        // Toggle phone filter flag
        this.showOnlyWithoutPhones = !this.showOnlyWithoutPhones;
        
        // Re-render to apply filter
        this.render();
        
        // Update toggle button text to reflect current state
        const toggleBtn = document.getElementById('btnTogglePhones');
        if (toggleBtn) {
            toggleBtn.innerText = this.showOnlyWithoutPhones 
                ? 'ðŸ“µ Show All Contacts' 
                : 'ðŸ“± Show Only Without Phones';
        }
    }

    /**
     * Render the contact grid
     * 
     * RENDERING PIPELINE:
     * 1. Clear existing grid content
     * 2. Update stats display (total count)
     * 3. Filter contacts by search term
     * 4. Sort contacts if alphabetical mode enabled
     * 5. Show empty state or create contact cards
     * 6. Update FAB (Floating Action Button) state
     * 
     * FILTER LOGIC:
     * - Case-insensitive search in full name (fn)
     * - Case-insensitive search in all phone numbers (tels)
     * - Contact matches if ANY field contains filter string
     * 
     * SORT LOGIC:
     * - If sortAZ = true: Sort alphabetically by full name
     * - If sortAZ = false: Keep creation/load order
     * 
     * PERFORMANCE NOTES:
     * - Batches all DOM updates in single render pass
     * - Uses innerHTML for stats (fast for simple text)
     * - Uses createElement + appendChild for cards (safer for dynamic content)
     * 
     * @returns {void}
     * 
     * @example
     * // Called after state changes
     * this.contacts = newContacts;
     * this.render(); // Update UI
     */
    render() {
        const grid = document.getElementById('grid');
        if (!grid) return;

        // Clear existing content
        grid.innerHTML = '';

        // === UPDATE STATS ===
        const statDisplay = document.getElementById('statDisplay');
        const btnExport = document.getElementById('btnExport');
        
        if (statDisplay) statDisplay.innerText = `${this.contacts.length} contacts`;
        if (btnExport) btnExport.innerText = `Export (${this.contacts.length})`;

        // === FILTER CONTACTS ===
        // Filter by name or phone numbers (case-insensitive)
        let visible = this.contacts.filter(c =>
            c.fn.toLowerCase().includes(this.filterStr) ||
            c.tels.some(t => t.includes(this.filterStr))
        );

        // Apply phone filter if enabled (show only contacts without phones)
        if (this.showOnlyWithoutPhones) {
            visible = visible.filter(c => c.tels.length === 0);
        }

        // === SORT CONTACTS ===
        // Apply alphabetical sort if enabled
        if (this.sortAZ) {
            visible.sort((a, b) => a.fn.localeCompare(b.fn));
        }

        // === SHOW EMPTY STATE ===
        if (visible.length === 0) {
            grid.innerHTML = `<div style="grid-column:1/-1; text-align:center; padding:3rem; color:#94a3b8">${Config.messages.noData}</div>`;
            return;
        }

        // === RENDER CONTACT CARDS ===
        visible.forEach(contact => {
            const card = this._createCard(contact);
            grid.appendChild(card);
        });

        // === UPDATE FAB ===
        // Show/hide and update floating action button
        this._updateFAB();
    }

    /**
     * Create a contact card element
     * 
     * CARD STRUCTURE:
     * - Badge: Selection number (1, 2, 3...)
     * - Name: Full name (bold, larger font)
     * - Organization: Company/org name (smaller, gray)
     * - Phone numbers: Up to maxTelsDisplay (3) shown with icons
     * - "More" indicator: Shows if more than maxTelsDisplay phones
     * 
     * SELECTION STATE:
     * - Selected cards have 'selected' class (background highlight)
     * - Badge shows selection order number (1-indexed)
     * - Card click toggles selection
     * 
     * PHONE NUMBER DISPLAY:
     * - Shows up to Config.ui.maxTelsDisplay (3) phone numbers
     * - Formats each with PhoneUtils.format() for display
     * - Shows "+N mas" if more phones exist
     * 
     * @private
     * @param {Contact} contact - Contact object to render
     * @returns {HTMLElement} DOM element (div.card) ready to append
     * 
     * @example
     * const card = this._createCard(contact);
     * grid.appendChild(card);
     */
    _createCard(contact) {
        // Check if this contact is selected
        const isSelected = this.selected.has(contact._id);
        
        // Get selection order (for badge number display)
        const selectionIndex = this.selectOrder.indexOf(contact._id);

        // Create card container
        const card = document.createElement('div');
        card.className = `card ${isSelected ? 'selected' : ''}`;
        
        // Add import group indicator if present (with validation)
        if (contact._importColor && isValidHexColor(contact._importColor)) {
            card.style.borderLeft = `4px solid ${contact._importColor}`;
            card.setAttribute('data-import-group', contact._importGroup);
            if (contact._importFileName) {
                card.setAttribute('title', `Importado de: ${escapeHtmlAttr(contact._importFileName)}`);
            }
        }
        
        // Bind click to toggle selection
        card.onclick = () => this.toggleSelect(contact._id);

        // Format phone numbers for display
        // Show up to maxTelsDisplay phones with formatting
        const telsHtml = contact.tels
            .slice(0, Config.ui.maxTelsDisplay)
            .map(t => `<span>ðŸ“ž ${PhoneUtils.format(t)}</span>`)
            .join('');

        // Show "more" indicator if additional phones exist
        const moreTels = contact.tels.length > Config.ui.maxTelsDisplay
            ? `<small style="color:#94a3b8">+${contact.tels.length - Config.ui.maxTelsDisplay} mas</small>`
            : '';

        // Build card HTML
        // Badge shows selection number (1-indexed) when selected
        card.innerHTML = `
            <div class="badge">${selectionIndex + 1}</div>
            <div style="font-weight:bold; font-size:1.05rem; margin-bottom:4px;">${contact.fn}</div>
            <div style="font-size:0.8rem; color:#64748b; margin-bottom:8px;">${contact.org || ''}</div>
            <div style="display:flex; flex-direction:column; gap:4px; font-size:0.85rem; color:#334155;">
                ${telsHtml}
                ${moreTels}
            </div>
        `;

        return card;
    }

    /**
     * Update the floating action button state
     * 
     * FAB BEHAVIOR:
     * - Hidden when no contacts selected
     * - Visible when 1+ contacts selected
     * - Shows selection count
     * - Button text changes based on selection:
     *   - 1 selected: "âœï¸ EDIT" (edit single contact)
     *   - 2+ selected: "âš¡ MERGE" (merge multiple contacts)
     * 
     * DOM ELEMENTS UPDATED:
     * - #fab: Main button (add/remove 'visible' class)
     * - #selCount: Selection count text
     * - #fabActionText: Action label (EDIT vs MERGE)
     * 
     * @private
     * @returns {void}
     */
    _updateFAB() {
        const fab = document.getElementById('fab');
        const selCount = document.getElementById('selCount');
        const fabActionText = document.getElementById('fabActionText');

        if (!fab) return;

        if (this.selected.size > 0) {
            // Show FAB when contacts selected
            fab.classList.add('visible');
            
            // Update selection count
            if (selCount) selCount.innerText = this.selected.size;
            
            // Update action text based on selection count
            if (fabActionText) {
                fabActionText.innerText = this.selected.size === 1 ? "âœï¸ EDIT" : "âš¡ MERGE";
            }
        } else {
            // Hide FAB when no selection
            fab.classList.remove('visible');
        }
    }

    /**
     * Toggle contact selection
     * 
     * SELECTION LOGIC:
     * - If already selected: Remove from both Set and order Array
     * - If not selected: Add to both Set and order Array
     * 
     * DUAL DATA STRUCTURE:
     * - selected (Set): Fast O(1) lookup for "is selected?" checks
     * - selectOrder (Array): Maintains selection order for badge numbering
     * 
     * After toggling, triggers re-render to update:
     * - Card visual state (selected class)
     * - Badge numbers (based on order)
     * - FAB visibility and text
     * 
     * @param {string} id - Contact ID (_id property)
     * @returns {void}
     * 
     * @example
     * // Called from card click handler
     * card.onclick = () => this.toggleSelect(contact._id);
     */
    toggleSelect(id) {
        if (this.selected.has(id)) {
            // Deselect: Remove from both structures
            this.selected.delete(id);
            this.selectOrder = this.selectOrder.filter(x => x !== id);
        } else {
            // Select: Add to both structures
            this.selected.add(id);
            this.selectOrder.push(id);
        }
        
        // Re-render to update UI
        this.render();
    }

    /**
     * Select all contacts
     * 
     * Adds all contacts to selection (both Set and order Array).
     * Only adds contacts that aren't already selected to preserve order.
     * 
     * USE CASE: Bulk operations (merge all, delete all)
     * 
     * @returns {void}
     * 
     * @example
     * // Called from "Select All" button
     * <button onclick="core.selectAll()">Seleccionar Todo</button>
     */
    selectAll() {
        this.contacts.forEach(c => {
            // Only add if not already selected (preserves order)
            if (!this.selected.has(c._id)) {
                this.selected.add(c._id);
                this.selectOrder.push(c._id);
            }
        });
        
        // Re-render to update UI
        this.render();
    }

    /**
     * Deselect all contacts
     * 
     * Clears both selection Set and order Array.
     * Also hides FAB (Floating Action Button) via re-render.
     * 
     * @returns {void}
     * 
     * @example
     * // Called from "Deselect All" button
     * <button onclick="core.deselectAll()">Deseleccionar</button>
     */
    deselectAll() {
        this.selected.clear();
        this.selectOrder = [];
        
        // Re-render to update UI
        this.render();
    }

    /**
     * Delete selected contacts
     * 
     * DELETION PROCESS:
     * 1. Show confirmation dialog with count
     * 2. If confirmed, filter out selected contacts
     * 3. Clear selection state
     * 4. Re-render UI
     * 
     * SAFETY:
     * - Requires user confirmation before deletion
     * - Cannot be undone (user must re-load VCF file)
     * 
     * @returns {void}
     * 
     * @example
     * // Called from Delete button
     * <button onclick="core.deleteSelected()">Eliminar</button>
     */
    async deleteSelected() {
        // Show confirmation dialog
        const confirmed = await Toast.confirm(Config.messages.confirmDelete(this.selected.size), 'Eliminar', 'Cancelar');
        if (!confirmed) return;
        
        // Filter out selected contacts
        this.contacts = this.contacts.filter(c => !this.selected.has(c._id));
        
        // Clear selection and re-render
        this.deselectAll();
    }

    /**
     * Clear all contacts
     * 
     * CLEAR PROCESS:
     * 1. Show confirmation dialog
     * 2. If confirmed, empty contacts array
     * 3. Clear selection state
     * 4. Re-render UI (shows empty state)
     * 
     * SAFETY:
     * - Requires user confirmation
     * - Cannot be undone (user must re-load VCF file)
     * - Different from deleteSelected (doesn't require selection)
     * 
     * USE CASE: Reset application to start fresh
     * 
     * @returns {void}
     * 
     * @example
     * // Called from Clear All button
     * <button onclick="core.clearAll()">Clear All</button>
     */
    async clearAll() {
        // Show confirmation dialog
        const confirmed = await Toast.confirm(Config.messages.confirmClear, 'Limpiar todo', 'Cancelar');
        if (confirmed) {
            // Empty the contacts array
            this.contacts = [];
            
            // Clear selection and re-render
            this.deselectAll();
        }
    }

    /**
     * Find a contact by ID
     * 
     * LOOKUP LOGIC:
     * - Linear search through contacts array
     * - Returns first contact with matching _id
     * - Returns undefined if not found
     * 
     * USED BY: MergeTool, AutoMerger for retrieving contact details
     * 
     * PERFORMANCE NOTE:
     * - O(n) linear search is acceptable for typical contact list sizes
     * - For very large lists, consider maintaining a Map<id, contact>
     * 
     * @param {string} id - Contact ID (_id property)
     * @returns {Contact|undefined} Contact object if found, undefined otherwise
     * 
     * @example
     * const contact = core.findById('k2x9f8h1643723456789');
     * if (contact) {
     *   console.log(contact.fn); // "John Doe"
     * }
     */
    findById(id) {
        return this.contacts.find(c => c._id === id);
    }

    /**
     * Add a new empty contact
     * 
     * Creates a new empty contact with minimal required fields and opens
     * the merge tool in edit mode for the user to fill in the details.
     * 
     * WORKFLOW:
     * 1. Generate unique ID for new contact
     * 2. Create contact with empty/minimal fields
     * 3. Add to beginning of contacts array (most recent)
     * 4. Select the new contact
     * 5. Open merge tool in edit mode
     * 
     * @returns {void}
     * 
     * @example
     * // Called from "Add Contact" button
     * <button onclick="core.addNewContact()">Add Contact</button>
     */
    addNewContact() {
        // Generate unique ID
        const newId = 'new_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
        
        // Create new empty contact
        const newContact = {
            _id: newId,
            fn: '',
            tels: [],
            emails: [],
            org: ''
        };
        
        // Add to beginning of contacts array
        this.contacts.unshift(newContact);
        
        // Select the new contact and open edit mode
        this.deselectAll();
        this.toggleSelect(newId);
        
        // Open merge tool in edit mode
        mergeTool.init();
        
        // Re-render to update UI
        this.render();
    }
}

// Export for module usage (ESM)
export default ContactManager;
